<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>interface | Youmekko</title><meta name="description" content="interface - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">interface</h1><div class="post-info"><a></a>2017-12-11</div><div class="post-content"><h2 id="인터페이스-interface"><a href="#인터페이스-interface" class="headerlink" title="인터페이스(interface)"></a>인터페이스(interface)</h2><p>자바에서 인터페이스는 객체의 사용 방법을 정의한 타입니다. (인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 특히 자바 8에서 인터페이스의 중요성은 더욱 커졌다. 자바8 의 람다식은 함수적 인터페이스의 구현 객체를 생성하기 때문이다.)<br>인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면, 인터페이스는 객체의 메소드를 호출 시킨다. 그렇기 때문에 개발코드는 객체 내부의 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다.</p>
<p>​              메소드호출                    메소드호출<br>개발  →→→→→→ →   인터  →→→→→→ →  객<br>코드  ←←←←← ←← 페이스 ←←←←← ←← 체<br>​                   리턴값                             리턴값</p>
<p>개발 코드가 직접 객체의 메소드를 호출하면 간단한데, 중간에 인터페이스를 두는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서이다. 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라 실행 내용과 리턴 값이 다를 수 있다.  따라서 개발 코드 측면에선느 코드 변경없이 실행내용과 리턴값을 다양화 할 수 있다는 장점을 가지게 된다.<br>(이것이 자바다 344p)</p>
<ul>
<li>클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는대 비해,<br>인터페이스는 상수와 메소드만 구성 멤버로 가진다.<br>인터페이스는 객체로 생성할 수 없기 때문에, 생성자를 가질 수 없다.<ul>
<li>자바7 이전까지는 인터페이스의 메소드는 실행 블록이 없는 추상 메소드만 선언이 가능했지만 자바 8 이후로는 default 메소드, static 메소드도 추가 가능.<ul>
<li>상수<br>: 인터페이스는 객체의 사용 설명서 이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없다. 그러나 상수 필드는 선언이 가능하다.<br>인터페이스의 선언된 필드는 모드 public static final의 특성을 갖지만 생략하더라고 자동적으로 컴파일 과정에서 붙게 된다.<br>static 블록으로 초기화 할 수 없기 때문에 반드시 선언과 동시에 초기 값을 지정해야 한다.</li>
<li>추상메소드<br>: 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어떤 매개값이 필요하고, 리턴 타입이 무엇인지만 알려준다. 실제 실행부는 객체(구현 객체)가 가지고 있다.<br>인터페이스에 선언된 추상 메소드는 public abstract의 특성을 갖기 때문에 public abstract를 생략해도 자동적으로 컴파일 과정에서 붙게 된다.</li>
<li>디폴드 메소드 : 인터페이스에 선언되지만, 사실은 객체(구현 객체 )가 가지고 있는 인스턴스 메소드라고 생각해야 한다. 자바 8에서 디폴드 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.<br>default 키워더가 리턴 타입 앞에 붙여야 한다. public은 생략 가능.</li>
<li>정적 메소드 : 디폴드 메소드와 달리 객체가 없어도 인터페이스 메소드만으로 호출이 가능하다.<br>public 생략 가능.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>인터페이스는 자식 클래스에 대한 가이드(설계도) 역할이다.</li>
<li>자식 클래스에서 인터페이스를 상속 받을 때 전용 키워드 implements 를 사용한다.</li>
<li>다중 상속 허용. 일반 상속과 겸용 가능.  <ul>
<li>다중 인터페이스를 구현할 경우, 자식(구현) 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 한다. 만약 하나라도 없으면 추상 클래스로 선언해야 한다.</li>
</ul>
</li>
<li>자식 클래스는 인터페이스의 추상 메소드에 대한 오버라이딩을 의무적으로 해야한다.<ul>
<li>자식(구현) 클래스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근제한자를 갖기 때문에 public 보다 더 낮은 접근 제한으로 작성 할 수 없다.</li>
<li>만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 자식(구현) 클래스가 작성하지 않으면 구현 클래스는 자동으로 추상 클래스가 된다. 그렇기 때문에 클래스 선언부에 abstract 키워드를 추가해야한다. (→ 추상클래스)</li>
</ul>
</li>
<li>자식(구현) 클래스가 작성되면 new 연산자로 객체를 생성 할 수 있다. 문제는 어떤 타입의 변수에 대입하냐 이다.<br>(ex) Television tv = new Television();  (X)<br>​        RemoteControl tv = new Television();  (O)<br>​        RemoteControl tv;<br>​        tv = new Television(); (O)</li>
</ul>
<p><strong>익명 구현 객체</strong><br>자식(구현) 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용 할 수 있기 때문에 편리하지만 일회성의 구현 객체를 만들기 위해서 소스파일을 만들고 클래스를 선언하는 것은 비효율 적이다.<br>자바는 소스파일을 만들지 않고도 구현객체를 만들수 있는 방법을 제공하는데 그것이 익명 구현 객체이다.<br> 작성시 주의 할점은 하나의 실행문 이므로 끝에는 세미콜론 (;) 을 반드시 붙여야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlExample</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    RemoteControl rc = <span class="keyword">new</span> remoteControl&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tunrOn</span><span class="params">()</span></span>&#123; <span class="comment">/* 실행문 */</span> &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tunrOff</span><span class="params">()</span></span>&#123; <span class="comment">/* 실행문 */</span> &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVolume</span><span class="params">()</span></span>&#123; <span class="comment">/* 실행문 */</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>모든 객체는 클래스로부터 생성되는데 익명 구현 객체도 예외는 아니다. RemoteControllerExample.java 를 컴파일 하면 자바 컴파일러에 의해서 자동으로 생성된다. 위의 경우 RemoteControllerExample$1.java 두번째 익명객체를 구현한 경우 RemoteControllerExample$2.java 가 된다. </p>
<h3 id="인터페이스의-사용"><a href="#인터페이스의-사용" class="headerlink" title="인터페이스의 사용"></a>인터페이스의 사용</h3><p>인터펭이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다. 인터페이스 변수는 참조 타입이기 때문에 객체가 대입 될 경우 구현 객체의 번지를 저장한다.<br>개발 코드에서 인터페이스는 클래스의 필드, 생성자 또는 메소드의 매개변수, 생성자 또는 메소드의 로컬 변수로 선언 될 수 있다.</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2017/12/20/2017-12-20-Java/">prev</a><a class="next" href="/2017/12/08/2017-12-08-BubbleSort/">next</a></div><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>