<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Vuex 살펴보기 | Youmekko</title><meta name="description" content="Vuex 살펴보기 - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vuex 살펴보기</h1><div class="post-info"><a></a>2019-06-04</div><div class="post-content"><p>참고 <a href="https://medium.com/@itsnothingg/%EB%8F%84%EB%8C%80%EC%B2%B4-vuex%EA%B0%80-%EB%AD%90%EA%B8%B8%EB%9E%98-ad5bc15f2371&gt;" target="_blank" rel="noopener">https://medium.com/@itsnothingg/%EB%8F%84%EB%8C%80%EC%B2%B4-vuex%EA%B0%80-%EB%AD%90%EA%B8%B8%EB%9E%98-ad5bc15f2371&gt;</a></p>
<h1 id="Vuex-미리-알아보기"><a href="#Vuex-미리-알아보기" class="headerlink" title="Vuex 미리 알아보기"></a>Vuex 미리 알아보기</h1><p>어플리케이션 데이터를 공유하는 구성 요소가 여러개 있으면, 그 구성요소들이 복잡하게 상호 작용할수록 데이터의 상태를 더이상 예측할 수 없거나 이해할 수 없는 지점까지 증가한다. 결국 어플리케이션을 확장하거나 유지 관리 할 수 없는 상황이 발생할 수 있다.</p>
<p> Flux의 개념은 이러한 결함을 충분히 완화시키는 확장 가능한 아키텍처를 설명하는 인력의 가이드 원칙들을 만든 것이다. 구성 요소 및 공유 데이터 상태가 복잡한 UI 앱에서 적용되는 개념이다.</p>
<p>Flux는 라이브러리가 아니라 패턴이다. (마치 MVC 같은.) Vuex나 Redux 같은 라이브러리는 마치 여러 프레임워크들이 MVC  패턴을 구현하듯이 Flux 패턴을 구현한 것이다. </p>
<p>Vuex는 Flux의 모든 패턴을 구현하진 않고 단지 하위의 일부분을 구현할 뿐이다.</p>
<h3 id="원칙1-Single-Source-of-Truth-단일-데이터-소스"><a href="#원칙1-Single-Source-of-Truth-단일-데이터-소스" class="headerlink" title="원칙1_ Single Source of Truth (단일 데이터 소스)"></a>원칙1_ Single Source of Truth (단일 데이터 소스)</h3><p>컴포넌트들은 자기만 신경쓰면 될 로컬 데이터들을 가지고 있다. 예를 들어 사용자 목록 컴포넌트의 스크롤 막대 위치는 다른 컴포넌트들에서는 관심이 없는 데이터이다.</p>
<p><strong>그러나 컴포넌트들 간에 공유해야 하는 데이터는 이를 사용하는 컴포넌트와는 별도로 단일 위치에 보관해야 한다.</strong></p>
<p>이 단일 위치를 <strong>store</strong>라고 한다. 컴포넌트는 이 위치에서 어플리케이션 데이터를 읽어야 하며 충돌이나 불일치를 방지하기 위해 복사본을 자체적으로 보관해서는 안된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">//state는 구성 요소들이 관찰할 어플리케이션 데이터</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    myValue: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123;myValue&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="comment">//컴포넌트들은 computed속성에서 store의 state를 가지고 올 수 있다.</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    myValue()&#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.myValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="원칙2-Data-i-Read-Only"><a href="#원칙2-Data-i-Read-Only" class="headerlink" title="원칙2_ Data i Read-Only"></a>원칙2_ Data i Read-Only</h3><p>컴포넌트들은 store에서 데이터를 자유롭게 읽을 수는 있지만 직접 변경할 수는 없다. </p>
<p>대신에 데이터를 변경할 것이라는 것을 store에 알려야 하면 store은 ‘mutations’ 라고 정의된 함수들을 통해 변경을 완수해야 할 책임이 있다.</p>
<p>왜 이렇게 번거롭게 접근을 할까? 이렇데 데이터 변경 로직을 중앙 집중화하면 데이터에 불일치가 일어나거나 데이터에 다른 문제들이 생겼을 때 여러곳을 일일이 뒤져볼 필요가 없다. 이것은 어떤 익명의 컴포넌트(아마도 써드파티 모듈)가 예상치 못한 방식으로 데이터를 변경할 가능성을 최소화 해준다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    myValue: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutataions:&#123;</span><br><span class="line">    increasement(state, value)&#123;</span><br><span class="line">      state.myValue += value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//store.myValue += 10; ===&gt; 이렇게 직접 접근하면 안됨</span></span><br><span class="line">store.commit(<span class="string">'increasement'</span>, <span class="number">10</span>) <span class="comment">//===&gt;적절한 mutaion 호출</span></span><br></pre></td></tr></table></figure>

<h3 id="원칙3-Mutations-Are-Synchronous"><a href="#원칙3-Mutations-Are-Synchronous" class="headerlink" title="원칙3_ Mutations Are Synchronous"></a>원칙3_ Mutations Are Synchronous</h3><p>위에 두가지 원칙을 지기킄 App에서 데이터를 디버그 하는 것이 훨씬 쉽다. mutation의 commit을 기록하고 응답 상태가 어떻게 변경되는지 관찰할 수 있다. (Vue Devtools에서 Vuex를 사용할 때 실제로 그렇게 디버그 할 수 있다.)</p>
<p>그러나 만약 mutaion이 비동기적으로 일어난다면 그런 방식의 디버깅은 불가능할 것이다. commit이 언제 발생했는지는 알 수 있어도 commit안에 콜백이나 Promise 같은 것들이 들어가면 추적이 불가능해진다.</p>
<p>mutaion이 동기적으로 일어나는 것, 데이터가 예측할 수 없는 이벤트의 순서와 시간에 종속되지 않도록 보장한다.</p>
<h3 id="결국-Vuex란"><a href="#결국-Vuex란" class="headerlink" title="결국 Vuex란?"></a>결국 Vuex란?</h3><p>Vuex는 Vue App에서 Flux 아키텍처를 구현하는데 도움이 되는 라이브러리다. 위에서 설명한 원칙들을 적용함으로써 Vuex는 여러 컴포넌트에서 데이터를 공유하는 경우에도 어플리케이션 데이터를 투명하고 예측 가능한 상태로 유지한다.</p>
<p>Vuex를 구현하기 위해서는 store, mutator가 포함되며 store에서 데이터를 읽는 모든 컴포넌트들을 자동으로 업데이트 한다.</p>
<p>또한 핫 모듈 리로딩(실행중인 App에서 모듈 업데이트) 및 시간 이동 디버깅(버그 추적을 위한 mutation 이벤트 역추적)과 같은 멋진 기능을 제공한다.</p>
<hr>
<p>참고 <a href="https://joshua1988.github.io/web-development/vuejs/vuex-start/" target="_blank" rel="noopener">https://joshua1988.github.io/web-development/vuejs/vuex-start/</a></p>
<h3 id="Vuex란"><a href="#Vuex란" class="headerlink" title="Vuex란"></a>Vuex란</h3><p>Vue.js의 상태관리를 위한 패턴이자 라이브리러이다.</p>
<h3 id="상태관리-State-Management-가-왜-필요한가"><a href="#상태관리-State-Management-가-왜-필요한가" class="headerlink" title="상태관리(State Management)가 왜 필요한가?"></a>상태관리(State Management)가 왜 필요한가?</h3><p>컴포넌트 기반 프레임워크에서는 화면 구성을 위해 화면 단위를 매우 잘게 쪼개서 컴포넌트를 사용한다. 예를 들면, header, button, list 등의 작은 단위들이 컴포넌트가 되어 한 화면에서 많은 컴포넌트를 사용하게 된다. 이에 따라 컴포넌트 간의 통신이나 데이터 전달을 좀 더 유기적으로 관리할 필요성이 생긴다.</p>
<p>달리말해 header -&gt; button, button -&gt; list, button-&gt; footer 등의 컴포넌트 간 데이터 전달 및 이벤트 통신 등의 여러 컴포넌트의 관계를 한곳에서 관리하기 쉽게 구조화 하는 것이 State Management다.</p>
<h3 id="상태-관리로-해결할-수-있는-문제점"><a href="#상태-관리로-해결할-수-있는-문제점" class="headerlink" title="상태 관리로 해결할 수 있는 문제점?"></a>상태 관리로 해결할 수 있는 문제점?</h3><p>상태 관리는 중대형 규모의 웹 컴포넌트들을 좀 더 효울적으로 관리하기 위한 기법이다. 일반적으로 앱의 규모가 커지면서 생기는 문제들은 다음과 같다.</p>
<p>(1) Vue 의 기본 컴포넌트 통신 방식인 상위 - 하위에서 중간에 거쳐야 할 컴포넌트들이 많아지거나</p>
<p>(2) 이를 피하기 위해 Event Bus를 활용해 상하위 관계가 아닌 컴포넌트 간 통신 시 관리가 되지 않는 점</p>
<p>이런 문제들을 해결하기 위해 모든 데이터 통신(state)를 한곡에서 중앙 집중식으로 관리한다.</p>
<p><img src="/img/2019-06-05-vuex-01.png" alt=""></p>
<h3 id="상태-관리-패턴"><a href="#상태-관리-패턴" class="headerlink" title="상태 관리 패턴"></a>상태 관리 패턴</h3><p>상태관리 구성 요소는 크게 3가지가 있다.</p>
<ul>
<li>state : 컴포넌트 간 공유될 data</li>
<li>view : 데이터가 표현될 template</li>
<li>action : 사용자의 입력에 따라 반응할 methods</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increasement()&#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>위 구성 요소는 아래와 같이 동작한다.</p>
<p><img src="/img/2019-06-05-vuex-02.png" alt=""></p>
<p>… 이 외에도 변경된 state값을 받아오기 위한 <strong>getters</strong>, state 값을 변경하기 위한 <strong>mutations</strong>, 비동기 mutations 로직을 위한 <strong>actions</strong>, 폴더 구조화 등을 알아야Vuex 를 잘 활용해 가독성 있는 코드를 짤 수 있다. </p>
<p>참고<a href="https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/" target="_blank" rel="noopener">https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/</a></p>
<h3 id="getters란"><a href="#getters란" class="headerlink" title="getters란?"></a>getters란?</h3><p>중앙 데이터식 관리 구조에서 발생하는 문제 중 하나는 각 컴포넌트에서 vuex의 데이터를 접근할 때 중복된 코드를 반복 호출하게 되는 것이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCount()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child.vue</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCount()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여러 컴포넌트에서 같은 로직을 비효율적으로 중복 사용하고 있다. 이 때 Vuex의 데이터(state) 변경을 각 컴포넌트에서 수행하는게 아니라 Vuex에서 수행하도록 하고 각 컴포넌트에서 수행로직을 호출하면 코드 가독성도 올라가고 성능에도 이점이 생긴다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store.js(Vuex)</span></span><br><span class="line">getters :&#123;</span><br><span class="line">  doubleCount: <span class="function"><span class="keyword">function</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//App.vue</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCount()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doubleCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child.vue</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCount()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doubleCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>비슷해 보일수 있지만 로직이 길다고 생각해보면 왜 getter를 쓰는게 편할지 납득이 간다.</p>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p>Vuex에 내장된 helper 함수, mapGetters로 이미 위에서 한번 가독성이 올라간 코드를 더 직관적이게 작성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  Parent counter : &#123;&#123; parentCount &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">computed: mapGetters(&#123;</span><br><span class="line">  parentCount : <span class="string">'getCount'</span> <span class="comment">//getCount는 Vuex의 getters에 선언된 속성 이름</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>또한 Vuex의 getters 속성 이름과 컴포넌트의 computed 속성을 동일하게 해 아래와 같이 선언할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  Parent counter : &#123;&#123; getCount &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed: mapGetters([</span><br><span class="line">  <span class="string">'getCount'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>여기서 주의할 점은 위 방법들은 컴포넌트 자체에서 사용할 computed 속성과 함께 사용할 수 없다는 점이다. 해별 방안은 ES6의 <code>...</code> 문법을 사용하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    <span class="string">'getCount'</span></span><br><span class="line">  ]),</span><br><span class="line">    anotherCounter()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다만 <code>...</code> 문법을 사용하려면 Babel-Stage …</p>
<p>..추가 예정</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2019/11/11/2019-11-11-DebouncingAndThrottling/">prev</a><a class="next" href="/2019/05/31/2019-05-31-events/">next</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'youmekko';
var disqus_identifier = '2019/06/04/2019-06-04-Vuex/';
var disqus_title = 'Vuex 살펴보기';
var disqus_url = 'http://yoursite.com/2019/06/04/2019-06-04-Vuex/';
(function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>