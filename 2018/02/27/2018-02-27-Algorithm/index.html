<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>(헬로코딩알고리즘) chapter1 소개 | Youmekko</title><meta name="description" content="(헬로코딩알고리즘) chapter1 소개 - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(헬로코딩알고리즘) chapter1 소개</h1><div class="post-info"><a></a>2018-02-27</div><div class="post-content"><h2 id="1-들어가는-글"><a href="#1-들어가는-글" class="headerlink" title="1. 들어가는 글"></a>1. 들어가는 글</h2><blockquote>
<p> 여러분이 원하는 프로그래밍 언어가 무엇이든 간에 대부분 이미 구현되어 있을 것 입니다. 그러므로 여러분이 스스로 모든 알고리즘을 코딩 해야할 필요는 없습니다. 하지만 여러가지 알고리즘들의 차이점을 이해하지 못한다며 미리 구현해 놓은 알고리즘은 별로 쓸모가 없습니다.</p>
</blockquote>
<h2 id="2-이진-탐색"><a href="#2-이진-탐색" class="headerlink" title="2. 이진 탐색"></a>2. 이진 탐색</h2><p>예) 전화번호 부에서 사람찾기, 페이스북 로그인 할때 DB에서 아이디 찾기, 1~100까지 중에 숫자 맞추기 게임(소주 뚜겅 숫자맞추기 게임이랑 똑같은거..ㅋㅋ)</p>
<p>이진 탐색은 알고리즘 이다. 입력으로는 정렬된 원소 리스트를 받는다. 이진 탐색 알고리즘은 리스트에 원하는 원소가 있으만 그 원소의 위치를 반환하고 아니면 null을 반환한다. </p>
<p>만약 n개의 원소를 가진 리스트에서 이진 탐색을 사용하면 최대 log2 n번만에 답을 찾을 수 있다. 단순 탐색이면 최대 n번이 필요할 수도 있다.</p>
<h3 id="로그"><a href="#로그" class="headerlink" title="로그"></a>로그</h3><p>log10 100은 [10을 몇번 곱해야 100이 되는걸까?] 하고 묻고 있는거다. 10x10은 = 100이니까 답은 2이다. 그러니까 로그 log10 100 = 2이다. <u>즉, 거듭제곱의 반대말이다.</u>  (이 책에서 빅오표기법을 사용해서 실행시간을 나타내는 방법을 알아볼텐데, 이때 모든 함수는 log₂를 뜻한다.) 단순 검색으로 원소를 찾을때는 최악의 경우 모든 원소를 살펴봐야 한다. 그러나 이진 탐색을 사용하면 최악의 경우에도 log n 개의 숫자만 확인하면 된다. 리스트에 숫자가 8개가 있따면 2의 3승 = 8, 즉 log8 = 3이므로 3번만 확인해도 된다. 원소가 1024이면 log1024 = 10이므로 10개만 확인해도 충분하다.</p>
<h3 id="이진-탐색은-리스트의-원소들이-정렬되어-있어야만-사용할-수-있다"><a href="#이진-탐색은-리스트의-원소들이-정렬되어-있어야만-사용할-수-있다" class="headerlink" title="이진 탐색은 리스트의 원소들이 정렬되어 있어야만 사용할 수 있다."></a>이진 탐색은 리스트의 원소들이 정렬되어 있어야만 사용할 수 있다.</h3><h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><ul>
<li>처음에는 배열 전체를 탐색한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">low = <span class="number">0</span></span><br><span class="line">hight = len(list) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>우선 가장 가운데 있는 원소를 확인해본다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mid = (low + high) </span><br><span class="line">guess = list[mid]  </span><br><span class="line"><span class="comment">#파이썬 버전2에서는 (low + high)가 짝수가 아닐 경우 자동으로 mid 값을 정수로 내림한다. mid = (low + high) / 2 에서 mid는 1이됨.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>만약 추측한 값이 찾으려는 값보다 작으면 low 값을 다음과 같이 변경한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> guess &lt; item: </span><br><span class="line">    low = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>만약 추측한 값이 너무 크면 high를 변경한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> guess &gt; item:</span><br><span class="line">    high = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>전체 코드</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        guese = list[mid]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#정답을 찾았을 때</span></span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment">#추측한 숫자가 정답보다 컸을때 mid - 1을 뺀다.</span></span><br><span class="line">        <span class="keyword">if</span> geuss &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment">#추측한 숫자가 정답보다 작았을 때 mid + 1을 한다.</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">   <span class="comment">#정답이 리스트에 없을 때         </span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> binary_search(my_list, <span class="number">3</span>)    <span class="comment">#1을 리턴</span></span><br><span class="line"><span class="keyword">print</span> birary_search(my_list, <span class="number">-1</span>)   <span class="comment">#None을 리턴</span></span><br></pre></td></tr></table></figure>

<h3 id="실행-속도"><a href="#실행-속도" class="headerlink" title="실행 속도"></a>실행 속도</h3><p>이진 탐색을 사용하면 얼마나 많은 시간을 절약할 수 있을까? 모든 원소를 확인 하는 방법을 쓰면 원소 100개가 있는 경우 100번 추측해야 한다. 그러니까 추측해야 할 최대 횟수는 리스트의 길이와 같다. 이런것을 <u>선형 시간(linear time)</u>이라고 한다.</p>
<p>이진탐색의 경우, 리스트 안에 원소의 개수가 100개 있다면 최대 7번만 추측해도 된다. 리스트의 길이가 40억개라고 해도 32번만 추측하면 댄다. 이진 탐색의 경우에는 로그시간logarithmic time으로 실행된다.</p>
<h2 id="3-빅오표기법"><a href="#3-빅오표기법" class="headerlink" title="3. 빅오표기법"></a>3. 빅오표기법</h2><p>빅오표기법은 알고리즘이 얼마나 빠른지 표시하는 특별한 방법이다.</p>
<p>예를 들어, 리스트의 크기가 n이라고 가정해보자. 단순 검색은 원소를 하나씩 확인하니까 n번을 연산해야 한다. 그래서 빅오 표기법에 따른 실행시간은 O(n)이다. ‘초’ 와 같은 시간단위는 없다. 빅오 표기법은 속도를 시간단위로 세지 않는다. 빅오 표기법은 연산 횟수를 비교하는 것이다. 빅오 표기법을 사용하면 수행해야 할 일이 많아질 때 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지 알 수 있다.</p>
<p>이진탐색은 크기가 n인 리스트를 확인하기 위해서 log n 번은 연산이 필요하다. 빅오표기법으로는 O(log n)이 된다. 일반적으로는 O(빅오의 O)(n)(n은 연산횟수) 처럼 표기한다. </p>
<p>빅오 표기법은 알고리즘이 동작하기 위해 필요한 연산 횟수를 나타내다. 이 연산 회수 앞에 커다란(Big) 알파벳 O를 쓰기 때문에 빅오표기법이라고 불린다.</p>
<h3 id="많이-사용하는-빅오-실행-시간의-예-빠른-순서대로"><a href="#많이-사용하는-빅오-실행-시간의-예-빠른-순서대로" class="headerlink" title="많이 사용하는 빅오 실행 시간의 예(빠른 순서대로)"></a>많이 사용하는 빅오 실행 시간의 예(빠른 순서대로)</h3><ul>
<li>O(log n) 로그시간 : 예) 이진 탐색</li>
<li>O(n) 선형시간 : 예) 단순 탐색</li>
<li>O(n * log n) : 예) 퀵정렬과 같으 빠른 정렬 알고리즘</li>
<li>O(n²) : 예) 선택정렬과 같이 느린 정렬 알고리즘</li>
<li>O(n!) : 예) 외판원 문제와 같이 정말 느린 알고리즘</li>
</ul>
<h3 id="빅오표기법에-대해-기억해야-할-것"><a href="#빅오표기법에-대해-기억해야-할-것" class="headerlink" title="빅오표기법에 대해 기억해야 할 것"></a>빅오표기법에 대해 기억해야 할 것</h3><ul>
<li>알고리즘의 속도는 시간이 아니라 연산횟수가 어떻게 증가하는지로 측정한다.</li>
<li>이렇게 하면 입력 데이터의 크기가 늘어날 때 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있다.</li>
<li>알고리즘의 실행시간은 빅오표기법으로 나타낸다.</li>
<li>O(log n)은 O(n)보다 빠르고, 찾으려는 리스트의 원소의 개수가 증가하면 상대적으로 더 빨라진다.</li>
</ul>
<h3 id="외판원-문제"><a href="#외판원-문제" class="headerlink" title="외판원 문제"></a>외판원 문제</h3><p>더 이상 알고리즘을 향상 시키는 것이 불가능하다고 생각되는 유명한 문제(traveling salesperson problem)</p>
<p>이 외판원은 다섯개의 도시를 방문해야한다. 이 외판원의 이름을 edwin이라고 하자. edwin은 가장 짧은 거리를 통해 다섯개의 도시를 모두 방문하고 싶다. 이 문제를 푸는 한가지 방법은 도시를 방문하는 모든 경로를 살펴보는 것이다.</p>
<p>그 다음 전체거리를 더해서 가장 짧은 경로를 택하면 된다. 도시가 5개 이면 120가지 경우가 있으므로 120번 연산을 하면된다. 도시가 6개가 되면 연산회수는 720번, 도시가 7개가 되면 5,040번이 된다.</p>
<p>만약 n개의 도시가 있다면 결과를 계산하는데 n!(n 팩토리얼)번의 연산이 필요하다. </p>
<h2 id="chapter1을-공부하고…"><a href="#chapter1을-공부하고…" class="headerlink" title="chapter1을 공부하고…"></a>chapter1을 공부하고…</h2><ul>
<li>이진 탐색에 대해 확실하게 기억하자!</li>
<li>log가 뭔지 알게됐다.(옛날옛날먼옛날부터 수포자.. 하지만 모르는걸 부끄러워하지 않는 용기를.. 핚!!)</li>
<li>빅오표기법에 대해 알게 됐다. 아직 익숙하진 않지만 자꾸 보다 보면 익숙해지겠지..?!</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/02/28/2018-02-28-JavaScript/">prev</a><a class="next" href="/2018/02/27/2018-02-27-W.I.L/">next</a></div><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>