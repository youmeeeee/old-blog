<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>(헬로코딩알고리즘) chapter3 재귀 | Youmekko</title><meta name="description" content="(헬로코딩알고리즘) chapter3 재귀 - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(헬로코딩알고리즘) chapter3 재귀</h1><div class="post-info"><a></a>2018-03-14</div><div class="post-content"><h2 id="재귀"><a href="#재귀" class="headerlink" title="재귀"></a>재귀</h2><p>큰 상자안에 작은 상자들이 들어있다. 작은 삭제들 중 한개에 들어있는 키를 찾는 알고리즘을 살펴보자.</p>
<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(main_box)</span>:</span></span><br><span class="line">    pile = main_box.make_a_pile_to_look_through()</span><br><span class="line">    <span class="keyword">while</span> pile <span class="keyword">in</span> <span class="keyword">not</span> empty:</span><br><span class="line">        box = pile.gram_a_box()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> box:</span><br><span class="line">            <span class="keyword">if</span> them.is_a_box():</span><br><span class="line">                pile.append(time)</span><br><span class="line">            <span class="keyword">elif</span> item.is_a_key:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"found a key!!!"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>재귀(recursion)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(box)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> box:</span><br><span class="line">        <span class="keyword">if</span> item.is_a_box():</span><br><span class="line">            look_for_key(item)   <span class="comment">#반복</span></span><br><span class="line">        <span class="keyword">elif</span> itme.is_a_key():</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"found a key!!!"</span></span><br></pre></td></tr></table></figure>
<p>재귀는 풀이를 명확하게 만들어 준다. 재귀를 쓴다고 성능이 더 나아지지는 않는다. 사실 반복문이 성능이 더 좋은 경우가 많다. </p>
<blockquote>
<p>프로그램에 반복문을 사용하면 프로그램의 성능을 향상 시킬 수 있지만, 재귀를 사용하면 프로그래머의 능력을 향상 시킬 수 있다. 상황에 따라 적절한 방법을 골라서 사용하세요.</p>
</blockquote>
<h2 id="기본-단계와-재귀-단계"><a href="#기본-단계와-재귀-단계" class="headerlink" title="기본 단계와 재귀 단계"></a>기본 단계와 재귀 단계</h2><p>재귀는 자기 자신을 호출하기 떄문에 실수로 무한 반복을 하는 함수를 만들기 쉽다.</p>
<p>재귀함수를 만들때는 언제 재귀를 멈출지 알려줘야한다. 그래서 모든 재귀함수닌 기본 단계(base case), 재귀 단계(recursive case)라는 두 부분으로 나누어져 있다. 재귀 단계는 함수가 자기 자신을 호출하는 부분이다. 기본 단계는 함수가 자기 자신을 다시 호출하지 않는 경우, 즉 무한 반복으로 빠져들지 않게 하는 부분이다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">1</span>:           <span class="comment">#기본단계</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">else</span>:                <span class="comment">#재귀단계</span></span><br><span class="line">        countdown(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="호출-스택-call-stack"><a href="#호출-스택-call-stack" class="headerlink" title="호출 스택(call stack)"></a>호출 스택(call stack)</h2><p>호출 스택은 프로그램에서 중요한 개념이다. 일반적인 프로그래밍에서도 중요하지만, 재귀를 사용할 때 더욱 중요하다. </p>
<p>포스티잇을 생각해보다. 새로운 포스트 잇을 추가할 때는 기존의 목록 위에 덧붙인다. 항목을 읽을 때에는 가장 위에 있는 항목만 읽고 때어낼 수 있다. 그러니까 push(삽입)와 pop(때어내고 읽기) 두가지만 할 수 있는 것이다. 이러한 자료구조를 스택이라고 한다. </p>
<p>컴퓨터는 호출 스택이라고 불리는 스택을 사용한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello, "</span> + name + <span class="string">"!"</span></span><br><span class="line">    greet2(name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"getting ready to say bye..."</span></span><br><span class="line">    bye()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"how are you, "</span> + name + <span class="string">"!"</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"ok bye!"</span></span><br><span class="line">    </span><br><span class="line">greet(<span class="string">"youmekko"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="재귀-함수에서-호출-스택-사용"><a href="#재귀-함수에서-호출-스택-사용" class="headerlink" title="재귀 함수에서 호출 스택 사용"></a>재귀 함수에서 호출 스택 사용</h3><p>재귀 함수에서도 호출 스택을 사용한다. 팩토리얼 함수(factorial funcion)가 어떻게 동작하는지 살펴보자. functional(5)는 5! 라는 뜻이고 5!는 5 X 4 X 3 X 2 X 1로 정의되는 값이다. 마찬가지로 fuctional(3)은 3X2X1이다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x * fact(x<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">fact(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>인터넷에서 주은 이미지<br><img src="/img/2018-03-14-callstack.jpg" alt=""></p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>재귀는 함수가 스스로를 호출하는 것이다.</li>
<li>모든 재귀 함수는 기본 단계와 재귀 단계라는 두 부분으로 나누어져 있다.</li>
<li>스택에는 push와 pop이라는 두 가지 연산이 있다.</li>
<li>모든 함수 호출은 호출 스택을 사용한다.</li>
<li>호출 스택(call stack)은 너무 커져서 메모리를 엄청나게 소비할 수도 있다.</li>
<li>의사코드(pseudocode)</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/03/21/2018-03-21-W.I.L/">prev</a><a class="next" href="/2018/03/13/2018-03-13-Algorithm/">next</a></div><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>