<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>(헬로코딩알고리즘) chapter7 다익스트라 알고리즘 | Youmekko</title><meta name="description" content="(헬로코딩알고리즘) chapter7 다익스트라 알고리즘 - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(헬로코딩알고리즘) chapter7 다익스트라 알고리즘</h1><div class="post-info"><a></a>2018-04-21</div><div class="post-content"><h3 id="너비우선탐색-vs-다익스트라-알고리즘"><a href="#너비우선탐색-vs-다익스트라-알고리즘" class="headerlink" title="너비우선탐색 vs 다익스트라 알고리즘"></a>너비우선탐색 vs 다익스트라 알고리즘</h3><p><img src="/img/2018-04-21-algorithm-01.jpeg" alt=""></p>
<h3 id="다익스트라-알고리즘-4단계"><a href="#다익스트라-알고리즘-4단계" class="headerlink" title="다익스트라 알고리즘 4단계"></a>다익스트라 알고리즘 4단계</h3><ol>
<li>가격이 가장 싼 정점, 즉 도달하는데 시간이 가장 적게 걸리는 정점을 찾는다.</li>
<li>이 정점의 이웃 정점에 대해 현재 가격보다 더 싼 경로가 존재하는지 확인한다. 만약 존재 한다면 가격을 수정한다.</li>
<li>그래프 상의 모든 정점에 대해 이런 일을 반복한다.</li>
<li>최종 경로를 계산한다.</li>
</ol>
<h3 id="용어"><a href="#용어" class="headerlink" title="용어"></a>용어</h3><ul>
<li>다익스트라 알고리즘을 사용할 때, 각 그래프의 간선은 어떤 숫자를 가진다. 이것을 가중치(weight)라고 한다.</li>
<li>가중치를 가지는 그래피는 가중 그래프(weight grpah)이다. </li>
<li>가중치가 없는 그래프는 균일 그래피( unweight graph)</li>
<li>그래프에는 Cycle이 있을 수도 있다.<br><img src="/img/2018-04-21-algorithm-02.jpeg" alt=""></li>
<li>다익스트라 알고리즘은 방향선 비순환 그래프(directed acyclic graph), 줄여서 DAG 라고 불리는 그래프에서만 적용된다.</li>
</ul>
<h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p><img src="/img/2018-04-21-algorithm-03.jpeg" alt=""></p>
<p><img src="/img/2018-04-21-algorithm-04.jpeg" alt=""></p>
<h3 id="간선의-가중치가-음수인-경우"><a href="#간선의-가중치가-음수인-경우" class="headerlink" title="간선의 가중치가 음수인 경우"></a>간선의 가중치가 음수인 경우</h3><p>음의 가중치를 가진 간선이 있으면 다익스트라 알고리즘을 사용할 수 없다. 음의 가중치를 가진 그래프에서 최단 경로를 찾고 싶으면 벨만- 포드 알고리즘(Bellman-Froad algorithm)을 사용하면 된다. </p>
<h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><p><img src="/img/2018-04-21-algorithm-05.jpeg" alt=""></p>
<p>위 예제를 코딩하려면 3개의 해시 테이블이 필요한다.</p>
<p><img src="/img/2018-04-21-algorithm-06.jpeg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#아직 처리하지 않은 가장 싼 정점을 찾는다.</span></span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"><span class="comment">#모든 정점을 처리하면 반복문이 종료된다.</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> : </span><br><span class="line">    cost = costs[node]</span><br><span class="line">    neighbors = graph[node]</span><br><span class="line">    <span class="comment">#모든 이웃에 대해 반복한다.</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():</span><br><span class="line">        new_cost = cost + neightbors[n]</span><br><span class="line">        <span class="comment">#만약 이 정점을 지나는 가격이 더 싸다면</span></span><br><span class="line">        <span class="keyword">if</span> costs[n] &gt; new_cost:</span><br><span class="line">            <span class="comment">#정점의 가격을 갱신하고</span></span><br><span class="line">            costs[n] = new_cost</span><br><span class="line">            <span class="comment">#부모를 이 지점으로 새로 설정한다.</span></span><br><span class="line">            parents[n] = node</span><br><span class="line">        <span class="comment">#정점을 처리한 사실을 기록한다.</span></span><br><span class="line">        processed.append(node)</span><br><span class="line">        node = find_lowest_cost_code(costs)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span><span class="params">(costs)</span>:</span></span><br><span class="line">    lowest_cost = float(<span class="string">"inf"</span>)</span><br><span class="line">    lowset_cost_node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line">            lowest_cost = cost</span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">        <span class="keyword">return</span> lowest_cost_node</span><br></pre></td></tr></table></figure>



<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul>
<li>다익스트라 알고리즘은 가중 그래프에서 최단 거리르 계산하는 데 사용한다.</li>
<li>다익스트라 알고리즘 모든 가중치가 양수일 때만 정상적으로 동작한다.</li>
<li>만약 가중치가 음수이면 벨만- 포드 알고리즘을 사용한다.</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/04/21/2018-04-21(Sat)-W.I.L/">prev</a><a class="next" href="/2018/04/20/2018-04-20(Fri)-W.I.L/">next</a></div><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>