<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>OracleSQL(4) 복수행(그룹) 함수 | Youmekko</title><meta name="description" content="OracleSQL(4) 복수행(그룹) 함수 - Youme Choi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Youmekko"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Youmekko" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Youmekko">Youmekko</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/youmekko" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OracleSQL(4) 복수행(그룹) 함수</h1><div class="post-info"><a></a>2018-01-11</div><div class="post-content"><h3 id="3장-복수행-그룹-함수"><a href="#3장-복수행-그룹-함수" class="headerlink" title="3장. 복수행(그룹) 함수"></a>3장. 복수행(그룹) 함수</h3><ol>
<li><p>그룹 함수의 종류</p>
<ul>
<li>복수행  함수는 한꺼번에 여러건의 데이터가 함수로 입력 된다.</li>
<li>사용방법은 일반 함수와 거의 비슷하므로 잘 숙지해둬야 한다.</li>
<li>모든 그룹 함수에서 가장 중요한 부분은 NULL 값의 포함 여부이다.</li>
<li>거의 대부분의 그룹 함수는 함수에 *을 사용하면 Null을 포함하고 컬럼 이름을 쓰면 해당 컬럼에 데이터가 있는 경우만!</li>
<li>즉, Null 값을 제외하고 작업을 해서 출력을 하게 된다.</li>
</ul>
<p>1-1. COUNT() 함수</p>
<ul>
<li>입력되는 데이터의 총 건수를 반환한다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(first_name)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1-2. SUM() 함수</p>
<ul>
<li>입력된 데이터들의 합계를 구하는 함수이다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(commission_pct), <span class="keyword">SUM</span>(commission_pct)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1-3. AVG() 함수</p>
<ul>
<li>입력된 값들의 평균 값을 구해주는 함수이다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(commission_pct), <span class="keyword">COUNT</span> (*), <span class="keyword">SUM</span>(commission_pct), <span class="keyword">AVG</span>(commission_pct)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"><span class="comment">--이렇게 하면 전체 인원 107명 중에서 commission_pct 값을 가지고 있는 35명의 평균이고</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(commission_pct), <span class="keyword">COUNT</span> (*), <span class="keyword">SUM</span>(commission_pct), <span class="keyword">AVG</span>(NVL(commission_pct,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"><span class="comment">--이렇게 하면 commission_pct가 null인 사람의 수도 포함해서 평균을 낸다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1-4.  MAX() 함수 / MIN 함수()</p>
<ul>
<li>MAX 함수는 주어진 데이터 중에 가장 큰 값을 돌려주고</li>
<li>MIN 함수는 주어진 반대로 가장 작은 값을 돌려준다.</li>
<li>이렇게 할 수 있는 원리는 MAX/MIN함수는 여러건의 데이터를 입력 받아 순서대로 정렬을 하고 그중에서 최대, 최솟값을 추출한다. →시간이 오래걸린다. → 사용할때 주의해야한다. → 인덱스를 활용하는게 더 좋은 방법이다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary), <span class="keyword">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--날짜의 경우 MAX가 가장 최신 날짜, MIN이 현재로부터 가장 먼 날짜가 출력된다.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(hire_date), <span class="keyword">MIN</span>(hire_date)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1-5. STDDEV() 함수 / VARIANCE() 함수</p>
<ul>
<li>STDDEV() 함수는 표준 편차를 구하는 함수이다.<ul>
<li>표준편차 : &lt;수학&gt; 자료의 분산 정도를 나타내는 수치. 분산의 양의 제곱근으로, 표준 편차가 작은 것은 평균값 주위의 분산의 정도가 작은 것을 나타낸다. </li>
</ul>
</li>
<li>VARIANCE() 함수는 분산을 구하는 함수이다.<ul>
<li>분산 : &lt;수학&gt; 통곗값과 평균값의 차이인 편차를 제곱하여 얻은 값들의 산술 평균. 분산이 작으면 자료는 평균값 주위에 모여 있게 되고,  분산이 크면 자료 가운데 평균값에서 멀리 떨어진 것이 많게 된다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STDDEV</span>(salary), <span class="keyword">VARIANCE</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>GROUP BY 절을 사용해 특정 조건으로 세부적인 그룹화 하기</p>
<ul>
<li><p>전체 값을 조회하는 것이 아니라 특정 조건을 주고 해당 조건에 맞는 결과들을 모아서 조금 더 구체적인 결과 만들기</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--department_id 별로 commission_pct 평균 내기</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="keyword">AVG</span>(NVL(commission_pct, <span class="number">0</span>)) <span class="string">"AVG"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure></li>
<li><p>세부적인 그룹핑 조건을 추가 하고 싶으면 위의 예 처럼 GROUP BY 절에 해당 컬럼명을 적으면 된다.</p>
</li>
<li><p>GROUP BY를 어려워 하는 사람들이 간혹 있는데 원리는 GROUP BY 뒤에오는 컬럼 값을 기준으로 먼저 모아 놓고, SELECT 절에 적혀있는 그룹함수를 적용하게 된다.</p>
</li>
<li><p>만약 그룹핑 할 조건이 여러개 일 경우 GROUP BY 절에 이어서 적으면 된다.</p>
</li>
<li><p>정렬이 필요한 경우 ORDER BY 절을 사용해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--department_id로 먼저 그룹핑을 한 후, 같은 department_id일 경우 job_id로 한번 더 분류해서 평균 commission_pct를 출력하기.</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">AVG</span>(NVL(commission_pct, <span class="number">0</span>)) <span class="string">"AVG_commission_pct"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--department_id로 먼저 그룹핑을 한 후, 같은 department_id일 경우 job_id로 한번 더 분류해서 평균 commission_pct를 출력하기</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">AVG</span>(NVL(commission_pct, <span class="number">0</span>)) <span class="string">"AVG_commission_pct"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GROUP BY 절을 사용할 때 주의사항</p>
<ul>
<li>(1) SELECT절에 사용된 그룹 함수 이외의 컬럼이나 표현식은 반드시 GROUP BY 절에 사용되야 한다. 그렇지 않으면 에러 발생. 하지만 GROUP BY 절에 사용된 컬럼이라도 SELECT절에는 사용하지 않아도 된다.</li>
<li>(2) GROUP BY 절에는 반드시 컬럼명이 사용되어야 하며 컬럼 Alias는  사용하면 안된다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>HAVING 절을 사용해 그룹핑한 조건으로 검색하기</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--commission_pct가 0.5이상인 부서의 부서번호와 평균 commission_pct 구하기</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="keyword">AVG</span>(NVL(commission_pct,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">AVG</span>(NVL(commission_pct, <span class="number">0</span>)) &gt; <span class="number">0.5</span> ;</span><br><span class="line"><span class="comment">--위처럼 작성하면 에러가 발생한다.</span></span><br><span class="line"><span class="comment">--이유는 WHERE절은 그룹 함수를 비교조건으로 쓸 수가 없기 때문이다.</span></span><br><span class="line"><span class="comment">--그룹 함수를 조건으로 사용하고 싶다면 WHERE 대신에 HAVING 절을 사용하면 해결된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--commission_pct가 0.5이상인 부서의 부서번호와 평균 commission_pct 구하기</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="keyword">AVG</span>(NVL(commission_pct,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt; <span class="number">50</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(NVL(commission_pct, <span class="number">0</span>)) &gt; <span class="number">0.2</span> ;</span><br></pre></td></tr></table></figure>
<ul>
<li>HAVING절의 위치는 GROUP BY 절 이전이든 이후든 상관없다.</li>
<li>그룹 함수를 사용하는 SQL이라고 하더라도 조건이 그룹 함수가 아닌 일반 조건일 경우 WHERE 문장을 쓸 수 있다.</li>
</ul>
</li>
<li><p>반드시 알아야 하는 다양한 분석 함수들</p>
<ul>
<li>row끼리 연산이나 비교를 쉽게 지원해주기 위한 함수를 분석함수(ANALYTIC FUNCTION) 또는 윈도 함수(WINDOW FUCNTION)라고 한다.</li>
</ul>
<p>4-1. ROLLUP() 함수</p>
<ul>
<li>각 기준별 소계를 요약해서 보여주는 함수</li>
<li>ROLLUP 함수는 GROUP BY 의 확장된 형태료 사용하기가 쉬우며, 복잡한 SQL을 짧게 만들고 해당 데이터들을 반복적으로 읽는 것을 최소화 해서 속도를 빠르게 해주는 등의 다양한 장점을 가진 함수다.</li>
<li>일반적으로 계층적 분류를 포함하고 있는 데이터의 집계에 적합하도록 되어있다.</li>
<li>ROLLUP()에 지정된 컬럼의 순서가 바뀌면 결과도 바뀌게 되므로 컬럼의 순서에 주의해야 한다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--예) 부서와 직업별 평균 급여 및 사원 수와 부서별 평균 급여와 사원수, 전체 사원의 평균 급여와 사원수</span></span><br><span class="line"><span class="comment">--문제 풀이에 필요한 것은</span></span><br><span class="line"><span class="comment">--(1)부서와 직업별 평균 급여 및 사원수</span></span><br><span class="line"><span class="comment">--(2)부서별 평균 급여와 사원 수</span></span><br><span class="line"><span class="comment">--(3)전체사원의 평균 급여와 사원 수</span></span><br><span class="line"><span class="comment">--가장 쉽게 푸는 방법은 위 3가지를 각 SQL로 만든 후 UNION ALL로 연결하면 된다.</span></span><br><span class="line"><span class="comment">--하지만 길고 복잡하므로 ROLLUP 함수를 사용해서 만들어보자.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(salary),<span class="number">1</span>) avg_sal, <span class="keyword">COUNT</span>(*) cnt_emp</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(department_id, job_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id, job_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">COUNT</span>(*), <span class="keyword">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, <span class="keyword">ROLLUP</span>(job_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">--hr.employees 테이블에서 부서번호(department_id)별로 인원수 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> NVL(department_id, <span class="number">-1</span>) department_id, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> NVL(department_id, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--hr.employees 테이블에서 부서번호(department_id)별로 인원수 및 인원수 총합 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> NVL(department_id, <span class="number">-1</span>)  department_id, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(NVL(department_id, <span class="number">-1</span>))</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--hr.employees 테이블에서 직위아이디(job_id)별로 인원수 및 인원수 총합 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(job_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--hr.employees 테이블에서 부서번호(department_id) 및 직위아이디(job_id)별로 인원수 및 인원수 소계, 총합 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(department_id, job_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id, job_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-2. CUBE() 함수</p>
<ul>
<li>CUBE 함수는 ROLLUP 함수와 같이 각 소계도 출력하고, 추가로 전체 총계까지 출력한다.</li>
<li>대신 추가로 전체 합계까지 보여주기 떄문에 집계 컬럼들이 가질 수 있는 모든 경우에 대하여 소계(소그룹)을 생성해야 하므로 ROLLUP 함수에 비해 시스템 리소르를 더 상ㅇ한다.</li>
<li>CUBE 함수의 집계 커럼들의 모둔 경우에 대한 소계를 구하므로 순서가 바뀌어도 데이터는 같다.<br>CUBE 함수를 사용하면 SQL이 훨씬 간결해지고 테이블도 1번만 읽는다.</li>
<li>ROLLUP함수와 CUBE 함수는 쿼리를 간결하게 하면서, 쿼리가 수행되는 속도도 빠르게 해주기 때문에 실무에서 대량의 데이터를 집계할 때 아주 많이 사용된다. 사용법이 조금 어려울 수 있으니, 반복적으로 공부하자!<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, job_id, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(salary), <span class="number">1</span>) avg_sal, <span class="keyword">COUNT</span>(*) cnt_temp</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span>(department_id, job_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id, job_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-3. GROUPING SETS() 함수</p>
<ul>
<li>그룹핑 조건이 여러개일 경우 유용하게 사용될 수 있다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--UNION 연산을 쓰느 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> salary, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> salary</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> commission_pct, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> commission_pct;</span><br><span class="line"></span><br><span class="line"><span class="comment">--GROUPING SETS()을 사용하는 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> NVL(salary,<span class="number">0</span>), NVL(commission_pct, <span class="number">0</span>), <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> <span class="keyword">SETS</span>(salary,commission_pct);</span><br><span class="line"></span><br><span class="line"><span class="comment">--하나의 테이블에 대한 여러가지 그룹함수가 사용된다면 GROUPING SETS() 를 활용하는 것이 좋다.</span></span><br><span class="line"><span class="comment">--manager_id별, jod_id별로 salary와 commission_pct의 합을 동시에 출력하기</span></span><br><span class="line"><span class="keyword">SELECT</span> manager_id, job_id, <span class="keyword">COUNT</span>(*), <span class="keyword">ROUND</span>(<span class="keyword">SUM</span>(salary),<span class="number">1</span>), <span class="keyword">SUM</span>(commission_pct)</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> <span class="keyword">SETS</span>(manager_id, job_id);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-4. LISTAGG() 함수 (11g에서 추가된 함수)</p>
<ul>
<li>쉽게 그룹핑을 해주는 함수</li>
<li>LISTAGG 함수에 나열하고 싶은 컬럼이름을 먼저 적고 데이터들을 구분할 구분자를 작은 따옴표 사이에 기록하면 된다.</li>
<li>WITHIN GROUP 사이에 가로로 나열하고 싶은 규칙을 ORDER BY 로 적어 주기만 하면 된다.</li>
<li>데이터를  구분할 구분자를 주지 않으면 모든 데이터가 한 줄로 연결되어 출력되기 떄문에 보기가 불편하다.</li>
<li>WITHING GROUP 절에 아무 조건도 주지 않으면 에러가 발생한다.</li>
<li>또한, LISTAGG 함수의 두번째 파라미터(각 데이터들끼리의 구분자)에 예약어도 사용할 수 없다.</li>
<li>주의사항) 리턴 되는 값이 400BYTE가 넘을 경우 오류가 발생한다. 이것을 처리하는 방법은 일단 패스.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> manager_id,</span><br><span class="line"><span class="keyword">LISTAGG</span>(first_name, <span class="string">' → '</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date) <span class="string">"LISTAGG"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-5. PIVOT() 함수 (11g에서 추가된 함수)</p>
<ul>
<li>PIVOT 함수는 row단위를 column 단위로 변경해주고 UNPIVOT는 반대로 column 단위를 row 단위로 변경해주는 기능을 한다.</li>
<li>출력시 가로(세로) 형태를 세로(가로) 형태로 바꿔주는 함수.</li>
<li>hr.employees 테이블에서 부서번호 및 직위아이디별 인원수 출력<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> employee_id, department_id, job_id <span class="keyword">FROM</span> hr.employees)</span><br><span class="line"><span class="keyword">PIVOT</span> (</span><br><span class="line">       <span class="keyword">COUNT</span>(employee_id) <span class="keyword">FOR</span> job_id <span class="keyword">IN</span> (<span class="string">'AD_ASST'</span>, <span class="string">'MK_MAN'</span>, <span class="string">'MK_REP'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-6. <del>UNPIVOT 함수 (일단 패스 PIVOT 어렵다)</del></p>
<p>4-7. LAG 함수</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, hire_date, salary</span><br><span class="line">, LAG(salary, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date) <span class="string">"LAG"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> first_name, hire_date, salary</span><br><span class="line">, LAG(salary, <span class="number">3</span>, <span class="number">2</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date) <span class="string">"LAG"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

<p>4-8. LEAD() 함수</p>
<ul>
<li>LEAD 함수는 LAG 함수와 반대로 이후의 값을 가져오는 함수이다.</li>
<li>문법이나 사용법은 LAG 함수와 동일하지만, OFFSET의 값이 가장 마지막에 보인다느 것만 다르다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, hire_date, salary</span><br><span class="line">, <span class="keyword">LEAD</span>(salary, <span class="number">2</span>, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date) <span class="string">"LAG"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-9. RANK() 함수</p>
<ul>
<li>RANK 함수는 주어진 컬럼 값의 그룹에서 값의 순위를 계산한 후 순위를 출력해준다.</li>
<li>같은 순위를 가지는 순위 기준에 대해서는 같은 출력 값을 가지기 때문에 출력 결과가 연속하지 않을 경우가 있다.</li>
<li>top-N과 botton-N등 순위를 출력하는 리포팅 작업에 아주 유용하게 사용할 수 있다.</li>
<li>특정 데이터의 순위만 볼수도 있고, 전체 데이터 순위를 볼 수도 있는데 두 가지 경우에 문법이 조금 다른다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--(1)특정 데이터의 순위 확인하기</span></span><br><span class="line"><span class="comment">--RANK(조건값) WITHIN GROUP(ODER BY 조건값 컬럼명 [ASC | DESC])</span></span><br><span class="line"><span class="comment">--주의사항)RANK뒤에 나오는 데이터와 ORDER BY 데이터 뒤에 나오는 데이터는 같은 컬럽이어야 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RANK</span>(<span class="string">'Adam'</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name) <span class="string">"RANK"</span>    </span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--(2)전체 순위 보기</span></span><br><span class="line"><span class="comment">--RANK() 뒤가 WITHING GROUP이 아니고 OVER로 바뀐다.</span></span><br><span class="line"><span class="comment">--RANK() OVER(ODER BY 조건컬럼명 [ASC | DESC] )</span></span><br><span class="line"><span class="comment">--salary 순위별로 출력하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, salary</span><br><span class="line">, <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">AS</span> RANK_ASC</span><br><span class="line">, <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> RANK_DESC</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--manager_id 100에 속한 직원들의 employee_id와, salary, manager_id내의 급여 순위 출력하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, salary,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="string">"RANK"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--manager_id별 급여 순위 출력하기</span></span><br><span class="line"><span class="comment">--PARTITION BY 구문 뒤에 그룹핑할 컬럼을 적어주면 된다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, manager_id,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="string">"RANK"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--employee_id, first_name, salary, manager_id 같은 job_id별로 급여 순위 출력</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, salary, manager_id, job_id,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id, job_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="string">"RANK"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>4-10.  DENSE_RANK 순위 함수</p>
<ul>
<li>RANK 함수와 비슷하다. 하지만 동일한 순위를 하나의 건수로 취급하므로 연속된 순위를 보여준다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, salary,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) sal_rank,</span><br><span class="line"><span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) sal_dense_rank</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br></pre></td></tr></table></figure>

<p>4-11. ROW_NUMBER() 함수</p>
<ul>
<li>RANK 함수와 DENSE_RANK 함수가 동일한 값에 대해서 동일한 순위를 부여하는데 반해 ROW_NUMBER() 함수는 동일한 값이라도 고유한 순위를 부여한다.</li>
<li>Oracle의 경우 ROWID가 작은 값에 먼저 순위를 부여한다.</li>
<li>중복된 순위가 없어서 RANK나 DENSE_RANK 함수보다 더 많이 사용하는 편이다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, salary,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) sal_rank,</span><br><span class="line"><span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) sal_dense_rank,</span><br><span class="line">ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) sal_row_number</span><br><span class="line"><span class="keyword">FROM</span> hr.employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--manager_id가 100, 120인 사원에서 manger_id별로 급여가 낮은 순으로 부여한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> first_name, salary, manager_id,</span><br><span class="line">ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) ROW_NUMBER1,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) RANK1,</span><br><span class="line"><span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) DENSE_RANK1,</span><br><span class="line">ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary, employee_id)  ROW_NUMBER2,</span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary, employee_id) RANK2,</span><br><span class="line"><span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manager_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary, employee_id) DENSE_RANK2</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span> (<span class="string">'120'</span>, <span class="string">'100'</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> manager_id, salary, employee_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>유일한 순위를 부여한다면 RANK, DENSE_RANK 함수보다 ROW_NUMBER 함수를 사용하면 된다.</li>
<li>ROW_NUMBER는 중복된 데이터가 있는 경우, ROWID가 작은 값에 먼저 순위를 부여하므로 중복된 순위가 없다.</li>
<li>하지만 ROWID가 바뀐 다면 항상 같은 결과의 순위를 보여줄 수는 없다.</li>
<li>항상 같은 정렬 순서를 보장하기 위해서는 반드시 유니크한 컬럼(예: PK컬럼들)을 기술해야 하는 것을 습관화 해야한다.</li>
</ul>
</li>
</ol>
<p>   4-12. SUM() OVER<br>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--누계 구하기 </span></span><br><span class="line"><span class="keyword">SELECT</span> ibsadate, city, ssn, sudang,</span><br><span class="line"><span class="keyword">SUM</span>(sudang) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sudang) <span class="string">"total"</span></span><br><span class="line"><span class="keyword">FROM</span> insa</span><br><span class="line"><span class="keyword">WHERE</span> city = <span class="string">'서울'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--개발부의 sudang을 city별로 분류한 뒤 ibsadate, city, ssn, sudang, total 을 출력하기</span></span><br><span class="line"><span class="keyword">SELECT</span> ibsadate, city, ssn, sudang,</span><br><span class="line"><span class="keyword">SUM</span>(sudang) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city <span class="keyword">ORDER</span> <span class="keyword">BY</span> sudang) <span class="string">"total"</span></span><br><span class="line"><span class="keyword">FROM</span> insa</span><br><span class="line"><span class="keyword">WHERE</span> buseo = <span class="string">'개발부'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--PARTITION BY 구문으로 세부적인 그룹핑을 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ibsadate, city, buseo, ssn, sudang을 city와 buseo별로 sudang구하기 정렬은 ibsadate로</span></span><br><span class="line"><span class="keyword">SELECT</span> ibsadate, city, buseo, ssn, sudang,</span><br><span class="line"><span class="keyword">SUM</span>(sudang) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city, buseo <span class="keyword">ORDER</span> <span class="keyword">BY</span> ibsadate) <span class="string">"total"</span></span><br><span class="line"><span class="keyword">FROM</span> insa;</span><br></pre></td></tr></table></figure></p>
<p>   4-13. PATIO_TO_REORT()<br>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--비율을 구하는 함수</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, last_name</span><br><span class="line">    ,department_id, salary</span><br><span class="line">    , <span class="keyword">SUM</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department_id) sum_</span><br><span class="line">    , <span class="keyword">ROUND</span>((salary/<span class="keyword">SUM</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department_id))*<span class="number">100</span>, <span class="number">1</span>) <span class="string">"ratio_%"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, last_name</span><br><span class="line">    ,department_id, salary</span><br><span class="line">    , <span class="keyword">SUM</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department_id) sum_</span><br><span class="line">    , <span class="keyword">ROUND</span>(RATIO_TO_REPORT(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department_id)*<span class="number">100</span>, <span class="number">1</span>) <span class="string">"ratio_%"</span></span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id;</span><br></pre></td></tr></table></figure></p>
<p>   <del>4-14. LAG()</del></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/01/11/2018-01-11-W.I.L/">prev</a><a class="next" href="/2018/01/10/2018-01-10-W.I.L/">next</a></div><div class="copyright"><p>&copy; 2016 - 2020 <a href="https://www.example.org/john-doe" target="_blank" rel="noopener">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>